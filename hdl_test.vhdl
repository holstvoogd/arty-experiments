-- generated by Digital. Don't modify this file!
-- Any changes will be lost if this file is regenerated.


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DIG_simpleClockDivider is
  port (
    cout: out std_logic;
    cin: in std_logic );
end DIG_simpleClockDivider;

architecture Behavioral of DIG_simpleClockDivider is
  component clockGenerator is
    port(
      cout: out std_logic;
      cin: in std_logic );
  end component clockGenerator;
begin
clock: component clockGenerator
    port map(
        cin => cin,
        cout => cout
    );
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;

entity DIG_Counter is
  generic ( Bits: integer ); 
  port (
    p_out: out std_logic_vector((Bits-1) downto 0);
    ovf: out std_logic;
    C: in std_logic;
    en: in std_logic;
    clr: in std_logic );
end DIG_Counter;

architecture Behavioral of DIG_Counter is
   signal count : std_logic_vector((Bits-1) downto 0) := (others => '0');
begin
    process (C, clr, en)
    begin
      if rising_edge(C) then
        if clr='1' then
          count <= (others => '0');
        elsif en='1' then
          count <= count + 1;
        end if;
      end if;
    end process;

    p_out <= count;
    ovf <= en when count = ((2**Bits)-1) else '0';
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity main is
  port (
    Clock: in std_logic;
    BTN0: in std_logic;
    BTN1: in std_logic;
    LED0: out std_logic;
    LED1: out std_logic;
    LED2: out std_logic;
    LED3: out std_logic);
end main;

architecture Behavioral of main is
  signal s0: std_logic;
  signal s1: std_logic_vector(3 downto 0);
begin
  gate0: entity work.DIG_simpleClockDivider
    port map (
      cin => Clock,
      cout => s0);
  gate1: entity work.DIG_Counter
    generic map (
      Bits => 4)
    port map (
      en => BTN0,
      C => s0,
      clr => BTN1,
      p_out => s1);
  LED0 <= s1(0);
  LED1 <= s1(1);
  LED2 <= s1(2);
  LED3 <= s1(3);
end Behavioral;
